<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Directed Graph Visualization</title>
    <style>
        .node circle {
            stroke: #fff;
            stroke-width: 1.5px;
        }

        table {
            width: 30%;
            border-collapse: collapse;
            margin: 25px 0;
            font-size: 16px;
            text-align: left;
        }

        th, td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #f2f2f2;
        }

    </style>
</head>
<body>
<table id="node-legend">
    <thead>
    <tr id="node-legend-row">
        <th>Node Legend</th>
    </tr>
    </thead>
    <tbody>
    <tr id="node-legend-color-row">
        <td>Color</td>
    </tr>
    </tbody>
</table>
<table id="edge-legend">
    <thead>
    <tr id="edge-legend-row">
        <th>Edge Legend</th>
    </tr>
    </thead>
    <tbody>
    <tr id="edge-legend-color-row">
        <td>Color</td>
    </tr>
    </tbody>
</table>
<div id="container" class="svg-container"></div>

<script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>

<script type="module">
    let n_ticked = 0;

    const graph_url = "http://127.0.0.1:18080/v1/graph";

    const node_domain = ['Pod', 'Service', 'ReplicaSet', 'StatefulSet', 'Deployment'];
    const node_color_range = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'];
    const node_color = d3.scaleOrdinal(node_domain, node_color_range);

    const edge_domain = ["Connected", "Own"]
    const edge_color_range = ['#a463f2', '#9498a0'];
    const edge_color = d3.scaleOrdinal(edge_domain, edge_color_range);
    let domain = [].concat.apply([], [node_domain, edge_domain]);
    let color_range = [].concat.apply([], [node_color_range, edge_color_range]);

    function isEmpty(obj) {
        return Object.keys(obj).length === 0;
    }

    function object_equals(x, y) {
        if (x === y) return true;
        // if both x and y are null or undefined and exactly the same

        if (!(x instanceof Object) || !(y instanceof Object)) return false;
        // if they are not strictly equal, they both need to be Objects

        if (x.constructor !== y.constructor) return false;
        // they must have the exact same prototype chain, the closest we can do is
        // test there constructor.

        for (var p in x) {
            if (!x.hasOwnProperty(p)) continue;
            // other properties were tested using x.constructor === y.constructor

            if (!y.hasOwnProperty(p)) return false;
            // allows to compare x[ p ] and y[ p ] when set to undefined

            if (x[p] === y[p]) continue;
            // if they have the same strict value or identity then they are equal

            if (typeof (x[p]) !== "object") return false;
            // Numbers, Strings, Functions, Booleans must be strictly equal

            if (!object_equals(x[p], y[p])) return false;
            // Objects and Arrays must be tested recursively
        }

        for (p in y)
            if (y.hasOwnProperty(p) && !x.hasOwnProperty(p))
                return false;
        // allows x[ p ] to be set to undefined

        return true;
    }


    function getObjectDiff(obj1, obj2) {

        function diff(obj1, obj2) {
            let result = {};

            // Helper function to determine if a value is an object
            const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

            // Helper function to determine if a value is an array
            const isArray = val => Array.isArray(val);

            // Helper function to compare arrays
            const compareArrays = (arr1, arr2) => {
                let diffArray = [];
                const maxLength = Math.max(arr1.length, arr2.length);
                for (let i = 0; i < maxLength; i++) {
                    if (!object_equals(arr1[i], arr2[i])) {
                        diffArray.push({
                            index: i,
                            oldValue: arr1[i],
                            newValue: arr2[i]
                        });
                    }
                }
                return diffArray.length > 0 ? diffArray : undefined;
            };

            // Collect keys from both objects
            const keys = new Set([...Object.keys(obj1 || {}), ...Object.keys(obj2 || {})]);

            keys.forEach(key => {
                if (isObject(obj1[key]) && isObject(obj2[key])) {
                    // Recursively compare nested objects
                    const nestedDiff = diff(obj1[key], obj2[key]);
                    if (Object.keys(nestedDiff).length > 0) {
                        result[key] = nestedDiff;
                    }
                } else if (isArray(obj1[key]) && isArray(obj2[key])) {
                    const arr0 = [...obj1[key]];
                    arr0.sort();
                    const arr1 = [...obj2[key]];
                    arr1.sort();
                    // Compare arrays
                    const arrayDiff = compareArrays(obj1[key], obj2[key]);
                    if (arrayDiff) {
                        result[key] = arrayDiff;
                    }
                } else if (obj1[key] !== obj2[key]) {
                    // Values are different
                    result[key] = {oldValue: obj1[key], newValue: obj2[key]};
                }
            });

            return result;
        }

        return diff(obj1, obj2);
    }


    function generate_legend(domain, color_range, descriptionRow, colorRow) {
        domain.forEach((description, index) => {
            const color = color_range[index];

            const descCell = document.createElement("th");
            descCell.textContent = description;
            descCell.style = "width: 90px;";

            const colorCell = document.createElement("td");
            colorCell.style.backgroundColor = color;

            descriptionRow.appendChild(descCell);
            colorRow.appendChild(colorCell);
        });
    }

    generate_legend(node_domain, node_color_range, document.getElementById("node-legend-row"), document.getElementById("node-legend-color-row"));
    generate_legend(edge_domain, edge_color_range, document.getElementById("edge-legend-row"), document.getElementById("edge-legend-color-row"));

    async function fetch_graph(url) {
        const r = await fetch(url);
        return r.json();
    }

    function intern(value) {
        return value !== null && typeof value === "object" ? value.valueOf() : value;
    }


    function DirectedGraph({
                               vertices, // an iterable of node objects (typically [{id}, …])
                               edges // an iterable of link objects (typically [{source, target}, …])
                           }) {
        let nodes = vertices.map(vertex => ({...vertex}));
        let links = edges.map(edge => ({...edge}));

        const width = window.innerWidth;
        const height = window.innerHeight;

        const nodeRadius = 8;
        const linkStrokeWidth = 1.5;

        const N = d3.map(nodes, d => d.id).map(intern);
        const forceNode = d3.forceManyBody();
        const forceLink = d3.forceLink(links).id(({index: i}) => N[i]);

        const simulation = d3.forceSimulation(nodes)
            .force("link", forceLink)
            .force("charge", forceNode)
            .force("center", d3.forceCenter())
            .force("x", d3.forceX())
            .force("y", d3.forceY())
            .on("tick", ticked);

        // Create the SVG container.
        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [-width / 2, -height / 2, width, height])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

        // Add a line for each link, and a circle for each node.
        let link = svg.append("g")
            .selectAll()
            .data(links)
            .join("line")
            .attr("stroke-width", linkStrokeWidth)
            .attr("stroke", d => edge_color(d.edge_type));

        let node = svg.append("g")
            .attr("stroke", "#fff")
            .attr("stroke-width", 1.5)
            .selectAll()
            .data(nodes)
            .join("circle")
            .attr("r", nodeRadius)
            .attr("fill", d => node_color(d.node_type));

        node.append("title")
            .text(d => d.name);

        // Add a drag behavior.
        node.call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

        // Set the position attributes of links and nodes each time the simulation ticks.
        function ticked() {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        }

        // Reheat the simulation when drag starts, and fix the subject position.
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        // Update the subject (dragged node) position during drag.
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        // Restore the target alpha so the simulation cools after dragging ends.
        // Unfix the subject position now that it’s no longer being dragged.
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }

        return Object.assign(svg.node(), {
            update({v, e}) {
                n_ticked = 0;

                // Make a shallow copy to protect against mutation, while
                // recycling old nodes to preserve position and velocity.
                const old = new Map(node.data().map(d => [d.id, d]));
                nodes = v.map(d => Object.assign(old.get(d.id) || {}, d));
                links = e.map(d => Object.assign({}, d));

                const N = d3.map(nodes, d => d.id).map(intern);
                const forceNode = d3.forceManyBody();
                const forceLink = d3.forceLink(links).id(({index: i}) => N[i]);

                simulation.nodes(nodes)
                    .force("link", forceLink)
                    .force("charge", forceNode);
                simulation.alpha(1).restart();

                node = node
                    .data(nodes, d => d.id)
                    .join(enter => {
                        return enter.append("circle")
                            .attr("r", nodeRadius)
                            .attr("fill", d => node_color(d.node_type));
                    })
                link = link
                    .data(links)
                    .join("line")
                    .attr("stroke-width", d => linkStrokeWidth)
                    .attr("stroke", d => edge_color(d.edge_type));


            }
        });
    }

    let graph = await fetch_graph(graph_url);
    let dg_svg = DirectedGraph({"vertices": graph.vertices, "edges": graph.edges});
    document.getElementById("container").appendChild(dg_svg);

    let interval = setInterval(() => {
        fetch_graph(graph_url)
            .then(new_graph => {
                const diff = getObjectDiff(graph, new_graph);
                if (!isEmpty(diff)) {
                    console.log("Diff between two graphs: ");
                    console.log(diff);
                }
                graph = new_graph;

                dg_svg.update({"v": new_graph.vertices, "e": new_graph.edges});
            })
    }, 300);

</script>
</body>
</html>
